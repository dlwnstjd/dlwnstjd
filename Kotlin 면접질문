# Scope Function

---

- 코틀린에서 제공하는 기본 라이브러리 함수로, 객체를 context내에서 코드 단위 블럭으로 실행하는데 목적을 가진 함수
- 5개의 스코프 함수가 존재 : let, run, with, apply, and also.

## 리시버와 람다 함수

- 스코프 함수를 사용할 때 넘겨주는 두 객체
- 차이점
    1. 객체를 접근하는 방법: this, it
    run, with, apply → this를 사용해 객체에 접근 
    let, also → it(람다 인자)을 사용해 객체에 접근
    2. 리턴 값
    apply, also → 리시버(context) 객체를 마지막에 리턴
    let, run with → 람다 함수의 마지막 결과를 리턴

## .let

- it 으로 리시버에 접근하고 람다 함수의 **마지막 결과를 리턴**
- 리시버의 여러 함수들을 호출할 때 사용
- 리시버 객체의 확장 함수로 사용 → val length = str?.let { it.length }

## .with

- this로 리시버에 접근, 람다 함수의 **마지막 결과를 리턴**(리턴 값을 사용하지 않는 경우에 쓸 것을 권장)
- 리시버 객체의 확장 함수로 사용하지 않음 → with(리시버 객체) { 람다 함수 }
- run 과 동일한 기능
- 인스턴스를 참조연산자 대신 parameter로 받아 사용(↔ run과 차이)

## .run

- this로 리시버에 접근하고, 람다 함수의 **마지막 결과를 리턴**
- 마지막 구문의 **결과 값을 반환**한다.(↔ apply와 차이)
- with 와 동일한 기능
- 리시버의 확장 함수(extension function)로 사용 → 리시버.run { 람다함수 }
- 람다함수에서 여러 값을 초기화하고 리턴 값을 어떤 객체의 초기값으로 사용할 때 사용
- 이미 인스턴스가 만들어진 후에 **인스턴스의 함수나 속성을 scope 내에서 사용**해야 할 때 사용한다.

## .apply

- this로 리시버에 접근하고, **리시버 객체를 리턴**
- 인스턴스를 생성한 후 변수에 담기 전에 **초기화 과정**을 수행할 때 많이 사용한다.
- main func과 별도의 scope 에서 **인스턴스의 변수와 함수를 조작**한다.

## .also

- it으로 리시버에 접근하고, **리시버 객체를 리턴**
- 리시버 스스로를 리턴하기 때문에 빌더패턴처럼 연속적으로 함수 호출 가능

처리가 끝나면 인스턴스를 반환 : apply, also

처리가 끝나면 최종 값을 반환 : run, let, with(?)

참조 연산자 없이 인스턴스의 변수와 함수 사용 → apply, run

파라미터로 인스턴스를 넘긴 것처럼 it을 통해 인스턴스를 사용 : also, let

# LiveData 란?

---
