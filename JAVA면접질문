# 프레임워크와 라이브러리

---

프레임워크와 라이브러리, 예를 들어 설명하자면!?

→ 자동차의 뼈대(**프레임워크**)가 있고 이 뼈대를 기초로 승용차, suv 등의 자동차를 완성한다. 여기에 추가적인 기능인 네비게이션이나 쿠션, 유리 등(**라이브러리**)을 가져와 차를 꾸민다.

## 프레임워크 란 ?

- 기본적인 뼈대가 완성되어 있고, 규칙이 존재하는 개발 환경

### 특징

1. 개발자들이 따라야 할 가이드라인을 가진다.
2. 개발할 수 있는 범위가 정해져 있다.
3. 개발자를 위한 다양한 도구들이 지원된다.

### 장점

1. 개발 편의성이 오르고 시간을 절약할 수 있다.
2. 오류의 폭을 좁힐 수 있다.
3. 어느 정도의 코드 품질을 보장한다.
4. 유지 보수하기 좋다.

### 단점

1. 프레임워크의 의존도가 늘어나 개발 능력이 저하될 수 있다.
2. 개발자의 자유도가 떨어진다.

## 라이브러리 란?

- 개발 시 활용 가능한 도구들을 모아 **모듈화**한 것

### 라이브러리와 API 차이

- 라이브러리 : 실제로 "실행이 되는 기능"을 담당하는 단편화된 프로그램
- API(Application Programming Interface) : 다른 목적으로 개발된 프로그램/라이브러리 들의 특정 기능을 "호출"하기 위해서 인터페이스를 노출시킨 것

### 프레임워크와 라이브러리 ?

- 프레임워크는 단순히 "라이브러리의 집합"은 아니다!
- 프레임워크는 개발자들의 "환경"을 제한하는 대신 일정 "환경"을 제공
- 라이브러리는 내가 원하는 코드를 원할 때 원하는 곳에 가져다 넣을 수 있다. → 즉, "환경"은 없고 **의도와 목적**만이 존재

# 프로그래밍 패러다임

---

## 명령형과 선언형

명령형 프로그래밍과 선언형 프로그래밍, 예를 들어 설명하자면!?

→ 로봇에게 "횡단 보도를 건너라" 라는 프로그래밍을 짠다고 가정하면, 

→ 명령형의 경우, "횡단 보도까지 이동", "초록불이 켜질때 까지 기다렸다가 켜지면 앞으로 이동" 의 지시를 해줘야 한다.

→ 선언형의 경우, "횡단 보도의 불이 초록불로 바뀌면 길을 건너" 라고 지시만 해주면 된다.

### 명령형 프로그래밍

- 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 방식
- "명령"의 수행, "어떻게(How to)"에 초점을 가진 프로그래밍
- **알고리즘**을 명시하고 목표는 명시하지 않는다. 위 예제를 보면, 로봇에게 "횡단보도를 건너는 방법"에 대한 **알고리즘**을 명시하지, 목적을 명시하지 않았다.
- 대표적인 예로 **절차적 프로그래밍**과 **객체 지향 프로그래밍**이 있고, 언어로 예를 들면, C, Java 등이 있다.

### 선연형 프로그래밍

- 어떤 방법으로 해야 하는지 보다 무엇과 같은 지를 설명하는 방식
- "함수"의 계산, "무엇(What)"에 초점을 가진 프로그래밍
- 알고리즘을 명시하지 않고 **목표**만 명시한다. 위 예제를 보면, 로봇에게 "초록불이 되면 길을 건너라" 라는 **목표**를 명시하지, 어떻게 건너라 라는 알고리즘을 명시하지 않았다.
- 대표적인 예로 **함수형 프로그래밍**이 있고, 언어로 예를 들면, Python, Kotlin 등이 있다.

# 오버로딩(Overloading)과 오버라이딩(Overriding)

---

## 오버로딩(Overloading)

- 같은 이름의 **메소드를 여러 개** 정의하는 것을 의미
- 매개 변수의 타입이 다르거나 개수가 다르다.
- return type과 접근 제어자는 영향을 주지 않는다.

→ 이사를 하는 것과 load, 즉 "짐을 싣다."라는 뜻을 가진 단어 관점에서 설명하자면, 트럭에 짐을 하나만 실을 수도, 여러 개를 실을 수도 있다. 또, 짐을 하나만 싣고 가는 트럭이 있을 수도 있고, 여러 짐을 싣고 가는 트럭이 있을 수도 있다. 하지만 하나를 싣던 여러 개를 싣던, 한대로 가던 여러 대로 가던 **이사짐 트럭**이라는 것에 변화가 없다. 이게 **오버로드** 라고 생각하면 된다.

## 오버라이딩(Overriding)

- 상속에서 나온 개념이며, 상위 클래스(부모 클래스)의 메소드를 하위 클래스(자식 클래스)에서 **재정의**한 것을 의미

→ ride, 즉, "타다"라는 뜻을 가진 단어 관점에서 설명하자면, 자전거도, 자동차도, 기차도 모두 "타다"의 넓은 범위가 된다. 즉, "타다"라는 단어에 무엇을 가져다 붙이는 지에 따라 **정의**가 달라진다. 이걸 **오버로딩** 이라고 생각하면 된다.

# 추상 클래스와 인터페이스

---

## 추상 클래스

- 추상화(abstract)된 class, 즉, 추상적인 내용을 가진, 부분적으로만 완성되어 있는 **미완성**된 메서드들을 포함하고 있는 클래스, **미완성 설계도**를 의미한다.
- 추상적인 내용을 담고 있다 보니, 인스턴스를 생성할 수 없고, **상속**을 통해 자손 클래스에서 완성할 수 있다.
- 공통된 내용을 상위 클래스로 뽑아 만든 것이 추상 클래스이며, 세부적으로 구현한 부분이 추상 메소드

### 목적

- 맥락에 따라서 내용이 달라질 때 추상 클래스와 메소드로 추상화, 즉, **분류하는 작업을 통해 중복을 줄이고 유지보수를 용이**하기 위해서 추상 클래스를 사용

## 인터페이스

- 일종의 추상 클래스로, 다른 점은 오직 추상 메소드와 상수만을 멤버로 가진다.
- 구현된 부분이 아무것도 없는, 밑 그림만 그려져 있는 **기본 설계도**를 의미한다.

### 목적

- 결합도가 낮은 코드를 만들어 협업과 유지보수가 용이해지도록 만드는 것

# 큐와 스택

---

## 큐(Queue)

- FIFO(First In First Out), 즉, 선입선출의 방식으로 동작하며, 프로세스 처리, CPU관리 등에 많이 사용된다.
- 큐에 자료를 한 개 집어 넣는 동작을 **인큐(EnQueue)** 라고 하며, 큐 안에 있는 자료를 한 개 꺼내는 동작을 **디큐(DeQueue)**라고 한다.
- 리스트를 이용한 큐 구현(Linear Queue(선형 큐)) 에서는 **디큐**로 맨 앞자리를 날렸을 때 남은 부분이 앞으로 한 칸씩 땡겨져 오다 보니 속도 측면에서 단점이 있다.
- Linear Queue를 보완하기 위해 Circular Queue(원형 큐)가 등장했고, 이는 디큐로 빼 놓은 자리에 인큐로 넣음으로써 낭비를 막는다.
- 예를 들어, 버스 또는 택시 등 줄 서기, 롤에서 "큐를 돌린다" 등의 예가 있다.

## 스택(Stack)

- LIFO(Last In First Out), 즉, 후입선출의 방식으로 동작하며, 문서 작업에서 ctrl+z, 캐시 등에 많이 사용된다.
- 예를 들어, 접시 또는 책 등을 쌓는다 등의 예가 있다.

# 세션과 쿠키

---

- HTTP(HyperText Transfer Protocol)은 브라우저 같은 응용 프로그램을 통해 사용자와 서버 사이에 전송하는 프로토콜이며, 이는 연결 상태를 유지하지 않는 **비 연결 프로토콜**이라는 특징을 가짐
- 사용자의 요청에 따라 서버에 접속해 응답 데이터를 전송한 뒤 연결을 종료시켜 주다 보니, 매 번 재 연결을 해야 했고, 이러한 단점을 해결하기 위해 **쿠키나 세션**을 사용한다.

## 쿠키(Cookie)

- 사용자의 브라우저에 저장되기 때문에 서버의 자원을 사용할 수 없고, 사용자의 컴퓨터만 있으면 누구나 쿠키 안에 데이터를 확인할 수 있기 때문에 보안성이 낮다.
- Cookie는 인터넷 사용자가 특정 웹서버에 접속할 때, 생성되는 개인 아이디와 비밀번호, 방문한 사이트의 정보를 담은 임시 파일로써, Server가 아닌 Client에 텍스트 파일로 저장되어 다음에 해당 웹서버를 찾을 경우 웹서버에서는 그가 누구인지 어떤 정보를 주로 찾았는지 등을 파악할 때 사용
- 예를 들어, 검색 키워드 정보나 자동 로그인 유지 정보, 팝업 보지 않기, 쇼핑 카트나 위시 리스트 저장, 특정 웹사이트에 방문한 적이 있는지, 또 접속했다면 얼마나 자주 방문했는지 등에 관한 정보들을 담고 있다.

## 세션(Session)

- 클라이언트와 웹 서버간에 네트워크 연결이 지속적으로 유지되고 있는 상태
- 서버에 접속하지 않는 이상 데이터를 탈취할 수 어렵기 때문에 중요한 데이터를 저장하는데 주로 사용
- 세션에 관련된 데이터는 서버에 저장 → 쿠키에 비해 보안성이 높음
- 웹 브라우저의 캐시에 저장되어 브라우저가 닫히거나 서버에서 삭제 시 사라짐
- 예를 들어, 로그인 정보 유지에 사용

## 캐시(Cache)

- 데이터나 값을 미리 복사해 임시로 저장해두는 장소를 의미

# Garbage Collector

---

참고 : [https://d2.naver.com/helloworld/1329](https://d2.naver.com/helloworld/1329)

Garbage 객체를 수집해 삭제하는 작업을 하는 것이 GC

### GC의 필수 개념인 stop-the-world

- GC를 실행하기 위해 JVM이 애플리케이션(world) 실행을 멈추는 것(stop)을 의미
- stop-the-world 발생 시 GC를 실행하는 Thread 제외한 나머지 모든 작업이 중단
- GC작업 완료 후 중단 됐던 작업들 재 실행

cf) GC를 튜닝한다!? 라는 말은 stop-the-world의 시간을 줄인다. 라는 것과 같다.

### Java는 프로그램 코드에서 명시적으로 메모리를 지정하여 해제하지 않기 때문에 GC가 더 이상 필요없는 쓰레기(Garbage) 객체를 찾아 삭제하는 작업을 한다.

- 명시적 해제를 위해 System.gc()를 호출할 순 있으나, 시스템 성능에 영향을 끼쳐 사용하지 않는 것을 추천(**무슨 시스템 성능에 어떤 영향을 끼칠까요...?**)

### GC가 만들어진 가설!!? 이유!?!

1. 대부분의 객체는 빠르게 접근 불가능(unreachable) 상태가 됨
2. 오래된(Old) 객체에서 젊은(Young) 객체로의 참조는 아주아주아주아주 적게 존재

→ 위 가설들을 **weak generational hypothesis** 라고 부름

### 위 2가지의 가설을 위해 Hotspot VM에서는 물리적 공간을 2개로 나눔

1. Young 영역
    - 새 객체들이 생성돼 위치하는 곳이며, 대다수 객체는 빠르게 unreachable 상태가 되므로 많은 객체들이 이 영역에서 생성되었다 사라진다.
    - 이 영역에서 객체가 사라질 때 **Minor GC**가 발생한다 한다.
2. Old 영역
    - unreachable 상태가 되지 않아 Young 영역에서 살아남은 객체가 복사되는 곳으로, Young 영역보다 크기가 크고 GC가 적게 일어난다.(Young영역은 생성되었다 사라지기 때문에 크기가 작아도 되며, 살아남은 객체들이 복사되다 보니 크기가 크고, 어디선가 사용하기 때문에 GC가 적게 일어난다고 이해...)
    - 이 영역에서 객체가 사라질 때 **Major GC**(or **Full GC**)가 발생한다고 한다.

[https://yaboong.github.io/java/2018/06/09/java-garbage-collection/](https://yaboong.github.io/java/2018/06/09/java-garbage-collection/)

# Process vs Thread

---

## Process vs Thread

- 참고 : [https://developer.android.com/guide/components/processes-and-threads.html?hl=ko#IPC](https://developer.android.com/guide/components/processes-and-threads.html?hl=ko#IPC)

### Process

- 운영체제로부터 자원을 할당받는 작업의 단위
- 컴퓨터에서 실행 중인 컴퓨터 프로그램

### Thread

- 프로세스가 할당받은 자원을 이용하는 **실행**의 단위
- 하나의 프로세스가 생성되면 하나의 스레드가 같이 생성 → 메인 스레드
- 여러 개의 스레드를 가질 수 있음 → 멀티 스레드

# HashMap or LinkedHashMap or ConcurrentHashMap

---

1. 셋의 정의 및 차이
2. HashMap은 Thread safe?
3. Hash가 들어간 자료구조들은 키 값을 어떻게 가지고 있는지?
4. Hashing 이란?

# Java Reference class의 용도와 종류

---

# Reflection 이란 무엇이며 언제 쓰나?

---

# Check exception, uncheck exception? uncheck exception의 종류

---

# 씨리얼 라이즈어블? 이 뭔지, 파스너블이 뭔지? 차이는 뭔지?

---

# Fragment 호출 시 newInstance 호출과 new Fragment 호출 차이

---

# Thread는 Looper를 가지고 있나?

---

# Handler 란?

---

### Thread, Handler, Looper

- 참고 : [https://itmining.tistory.com/5?category=640759](https://itmining.tistory.com/5?category=640759)
- Android UI는 기본적으로 Main Thread 를 주로 사용하는 Single Thread Model로 동작하므로, Main Thread에서 긴 작업은 피해야 한다.
- 즉, 긴 작업은 다른 스레드에서 실행하며, UI를 바꿀 때는 UI Thread로 접근해야 하는데, 이 때 사용하는 것이 Message or Runnable 객체를 받아와 다른 곳으로 전달해주는 **Handler class** 이다.
- 핸들러를 생성하는 스레드 만이 다른 스레드가 전송하는 Message와 Runnable 객체를 받을 수 있다.

### Handler

- 단어 의미 그대로 무언가를 처리하는 놈 입니다. 이 친구는 Message와 Runnable 객체를 처리
